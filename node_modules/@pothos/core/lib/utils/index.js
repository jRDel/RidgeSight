"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    assertNever: true,
    assertArray: true,
    isThenable: true,
    verifyRef: true,
    verifyInterfaces: true,
    brandWithType: true,
    getTypeBrand: true
};
exports.assertNever = assertNever;
exports.assertArray = assertArray;
exports.isThenable = isThenable;
exports.verifyRef = verifyRef;
exports.verifyInterfaces = verifyInterfaces;
exports.brandWithType = brandWithType;
exports.getTypeBrand = getTypeBrand;
var _types = require("../types");
var _contextCache = _interopRequireWildcard(require("./context-cache"));
Object.keys(_contextCache).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _contextCache[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _contextCache[key];
        }
    });
});
var _enums = _interopRequireWildcard(require("./enums"));
Object.keys(_enums).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _enums[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _enums[key];
        }
    });
});
var _input = _interopRequireWildcard(require("./input"));
Object.keys(_input).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _input[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _input[key];
        }
    });
});
var _params = _interopRequireWildcard(require("./params"));
Object.keys(_params).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _params[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _params[key];
        }
    });
});
var _sortClasses = _interopRequireWildcard(require("./sort-classes"));
Object.keys(_sortClasses).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _sortClasses[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _sortClasses[key];
        }
    });
});
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function assertNever(value) {
    throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
    if (!Array.isArray(value)) {
        throw new TypeError('List resolvers must return arrays');
    }
    return true;
}
function isThenable(value) {
    return !!(value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function');
}
function verifyRef(ref) {
    if (ref === undefined) {
        throw new Error(`Received undefined as a type ref.
        
This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
    }
}
function verifyInterfaces(interfaces) {
    if (!interfaces || typeof interfaces === 'function') {
        return;
    }
    if (!Array.isArray(interfaces)) {
        throw new TypeError('interfaces must be an array or function');
    }
    for (const iface of interfaces){
        if (iface === undefined) {
            throw new Error(`Received undefined in list of interfaces.
        
This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
        }
    }
}
function brandWithType(val, type) {
    if (typeof val !== 'object' || val === null) {
        return;
    }
    Object.defineProperty(val, _types.typeBrandKey, {
        enumerable: false,
        value: type
    });
}
function getTypeBrand(val) {
    if (typeof val === 'object' && val !== null && _types.typeBrandKey in val) {
        return val[_types.typeBrandKey];
    }
    return null;
}

//# sourceMappingURL=index.js.map